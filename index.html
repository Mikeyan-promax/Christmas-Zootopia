<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic Snowy Christmas</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Playfair+Display:ital,wght@0,400;1,400&display=swap" rel="stylesheet">
    <style>
        :root {
            --gold: #FFD700;
            --glass-bg: rgba(10, 25, 40, 0.65);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            /* Êõ¥Âä†Ê∑±ÈÇÉÁöÑÂçàÂ§úËìùËÉåÊôØÔºåË°¨ÊâòÈõ™Ëä± */
            background: radial-gradient(circle at 50% 30%, #1a2a3a 0%, #000510 100%);
            font-family: 'Playfair Display', serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* --- UI ÂçáÁ∫ß --- */
        #ui-layer {
            position: absolute;
            top: 50%;
            left: 40px;
            transform: translateY(-50%);
            z-index: 10;
            pointer-events: none;
        }

        .card-panel {
            background: var(--glass-bg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: 3px solid var(--gold);
            padding: 25px;
            border-radius: 4px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            backdrop-filter: blur(12px); /* Êõ¥Âº∫ÁöÑÁ£®Á†ÇÊÑü */
            max-width: 280px;
            color: #e0e0e0;
        }

        h1 {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            font-size: 1.6rem;
            margin: 0 0 15px 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }

        #gesture-debug {
            font-family: 'Cinzel', serif;
            color: #fff;
            font-size: 1rem;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            min-height: 1.2em;
        }

        .instruction-list {
            padding-left: 0;
            list-style: none;
            line-height: 1.8;
            font-size: 0.9rem;
            color: #ccc;
        }
        
        .instruction-list li {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .instruction-list span.icon {
            font-size: 1.2rem;
            margin-right: 10px;
            width: 25px;
            text-align: center;
        }
        
        .instruction-list span.key { color: var(--gold); font-weight: bold; margin-right: 5px; }

        #upload-btn {
            pointer-events: auto;
            margin-top: 20px;
            background: linear-gradient(45deg, rgba(255,215,0,0.1), rgba(255,215,0,0.2));
            color: var(--gold);
            border: 1px solid rgba(255,215,0,0.4);
            padding: 12px 0;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            transition: 0.4s;
            width: 100%;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.9rem;
        }

        #upload-btn:hover { 
            background: rgba(255, 215, 0, 0.3); 
            box-shadow: 0 0 15px rgba(255,215,0,0.2);
        }

        #video-wrapper {
            position: absolute;
            bottom: 30px;
            right: 30px;
            border: 1px solid rgba(255,215,0,0.3);
            padding: 4px;
            border-radius: 4px;
            opacity: 0.6;
            z-index: 10;
            background: rgba(0,0,0,0.3);
            transition: opacity 0.3s;
        }
        #video-wrapper:hover { opacity: 1; }

        #video-preview {
            display: block;
            width: 140px;
            height: 105px;
            transform: scaleX(-1);
            background: #000;
        }

        #file-input { display: none; }
        #ui-layer { display: none !important; }
        #video-wrapper { display: none !important; }
        
        #loading {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.95);
            color: var(--gold);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            font-family: 'Cinzel', serif; font-size: 1.5rem;
            z-index: 99; display: none;
        }
        #loading span { font-size: 1rem; margin-top: 10px; color: #888; font-family: sans-serif; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="card-panel">
            <h1>Winter Gallery</h1>
            <div id="gesture-debug">Waiting for Hands...</div>
            <ul class="instruction-list">
                <li><span class="icon">‚úä</span> <span class="key">Fist</span> to Gather</li>
                <li><span class="icon">üñê</span> <span class="key">Open</span> to Scatter</li>
                <li><span class="icon">üëà</span> <span class="key">Move</span> to Rotate</li>
                <li><span class="icon">üëå</span> <span class="key">Pinch</span> to Zoom Photo</li>
            </ul>
            <button id="upload-btn" onclick="document.getElementById('file-input').click()">Upload Memories</button>
            <input type="file" id="file-input" multiple accept="image/*">
        </div>
    </div>

    <div id="loading">DECORATING TREE...<br><span>Generating Snowflakes</span></div>
    <div id="video-wrapper"><video id="video-preview" playsinline></video></div>
    <div id="canvas-container"></div>

    <!-- Import Maps -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const CONFIG = {
            colors: {
                pine: 0x2a6b41,
                gold: 0xFFD700,
                red: 0x8a0303,
                ribbon: 0xFCE6C9,
                snow: 0xFFFFFF
            },
            treeHeight: 130,
            treeRadius: 45,
            particleCount: 600, 
            photoSize: 15
        };

        let scene, camera, renderer, composer;
        let particles = [];
        let snowSystem;
        let photoTextures = [];
        let currentState = 'TREE';
        let targetRotationY = 0;
        let activePhotoIndex = -1;
        let raycaster = new THREE.Raycaster();
        let highlightedIndex = -1;
        
        const gestureText = document.getElementById('gesture-debug');
        const loadingScreen = document.getElementById('loading');

        function initThree() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            // ÈõæÊïàÊîπ‰∏∫ÂÜ∑Ë∞ÉÁÅ∞ËìùËâ≤ÔºåÂ¢ûÂº∫Èõ™Â§©Ê∞õÂõ¥
            scene.fog = new THREE.FogExp2(0x0a101a, 0.002);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 60, 180);
            camera.lookAt(0, 60, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0; 
            renderer.shadowMap.enabled = true; 
            container.appendChild(renderer.domElement);

            // --- ÁÅØÂÖâÁ≥ªÁªü (Realistic) ---
            const ambient = new THREE.AmbientLight(0xffffff, 0.4); 
            scene.add(ambient);

            const mainLight = new THREE.PointLight(0xffeebb, 1.5, 400);
            mainLight.position.set(50, 100, 80);
            scene.add(mainLight);

            const rimLight = new THREE.SpotLight(0x66aaff, 4);
            rimLight.position.set(-60, 80, -60);
            rimLight.lookAt(0, 50, 0);
            scene.add(rimLight);

            const groundLight = new THREE.PointLight(0xaaccff, 0.5, 100);
            groundLight.position.set(0, -10, 0);
            scene.add(groundLight);

            const planeGeo = new THREE.CircleGeometry(100, 32);
            const planeMat = new THREE.MeshStandardMaterial({
                color: 0xeeeeff,
                roughness: 0.8,
                metalness: 0.1,
            });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -5;
            scene.add(plane);

            createSnowSystem();

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.8; 
            bloomPass.strength = 1.2; 
            bloomPass.radius = 0.4;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            generateParticles();
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        // --- Êö¥È£éÈõ™Á≥ªÁªü ---
        function createSnowSystem() {
            const snowGeo = new THREE.BufferGeometry();
            const snowCount = 1500;
            const posArray = new Float32Array(snowCount * 3);
            const velArray = []; 

            for(let i=0; i<snowCount; i++) {
                posArray[i*3] = (Math.random() - 0.5) * 400; 
                posArray[i*3+1] = Math.random() * 300;       
                posArray[i*3+2] = (Math.random() - 0.5) * 400; 
                
                velArray.push({
                    y: 0.2 + Math.random() * 0.5, 
                    x: (Math.random() - 0.5) * 0.1, 
                    z: (Math.random() - 0.5) * 0.1
                });
            }

            snowGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            
            const snowMat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.8,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            snowSystem = new THREE.Points(snowGeo, snowMat);
            snowSystem.userData = { velocities: velArray };
            scene.add(snowSystem);
        }

        function updateSnow() {
            if(!snowSystem) return;
            const positions = snowSystem.geometry.attributes.position.array;
            const vels = snowSystem.userData.velocities;

            for(let i=0; i<vels.length; i++) {
                positions[i*3] += vels[i].x;   
                positions[i*3+1] -= vels[i].y; 
                positions[i*3+2] += vels[i].z; 

                if (positions[i*3+1] < -10) {
                    positions[i*3+1] = 200;
                    positions[i*3] = (Math.random() - 0.5) * 400;
                    positions[i*3+2] = (Math.random() - 0.5) * 400;
                }
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
            snowSystem.rotation.y += 0.0005;
        }

        const geometries = {
            pine: new THREE.TetrahedronGeometry(1.5, 0), 
            sphere: new THREE.SphereGeometry(1, 24, 24),
            box: new THREE.BoxGeometry(1.2, 1.2, 1.2),
            star: new THREE.OctahedronGeometry(4, 0)
        };

        const materials = {
            pine: new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.pine, 
                roughness: 0.8, 
                flatShading: true 
            }),
            ornamentGold: new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.gold, 
                metalness: 0.9, 
                roughness: 0.1,
                emissive: 0xffaa00,
                emissiveIntensity: 1.0
            }),
            ornamentRed: new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.red, 
                metalness: 0.5, 
                roughness: 0.3,
                emissive: 0x550000,
                emissiveIntensity: 0.5
            }),
            ribbon: new THREE.MeshStandardMaterial({
                color: CONFIG.colors.ribbon,
                emissive: CONFIG.colors.ribbon,
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2
            }),
            star: new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 2.0
            })
        };

        function generateParticles() {
            particles.forEach(p => scene.remove(p.mesh));
            particles = [];

            createParticle('STAR', new THREE.Vector3(0, CONFIG.treeHeight + 2, 0));

            if (photoTextures.length > 0) {
                photoTextures.forEach(tex => {
                    const h = 20 + Math.random() * (CONFIG.treeHeight - 35); 
                    const rMax = (1 - h / CONFIG.treeHeight) * CONFIG.treeRadius;
                    const r = rMax + 7; 
                    const theta = Math.random() * Math.PI * 2;
                    const pos = new THREE.Vector3(r * Math.cos(theta), h, r * Math.sin(theta));
                    createPhotoParticle(tex, pos);
                });
            }

            const ribbonCount = 180;
            for (let i = 0; i < ribbonCount; i++) {
                const t = i / ribbonCount;
                const h = t * CONFIG.treeHeight;
                const r = (1 - t) * (CONFIG.treeRadius + 4); 
                const theta = t * Math.PI * 2 * 5.5; 
                const pos = new THREE.Vector3(r * Math.cos(theta), h, r * Math.sin(theta));
                createParticle('RIBBON', pos);
            }

            const bodyCount = CONFIG.particleCount - particles.length;
            for (let i = 0; i < bodyCount; i++) {
                const h = Math.random() * CONFIG.treeHeight;
                const rMax = (1 - h / CONFIG.treeHeight) * CONFIG.treeRadius;
                const r = Math.sqrt(Math.random()) * rMax; 
                const theta = Math.random() * Math.PI * 2;
                const pos = new THREE.Vector3(r * Math.cos(theta), h, r * Math.sin(theta));

                const isSurface = r > rMax * 0.75;
                let type = 'PINE';
                if (isSurface) {
                    const rand = Math.random();
                    if (rand > 0.85) type = 'GOLD_BALL';
                    else if (rand > 0.75) type = 'RED_BALL';
                }
                createParticle(type, pos);
            }
        }

        function createParticle(type, pos) {
            let mesh, scale = 1;
            
            if (type === 'STAR') {
                mesh = new THREE.Mesh(geometries.star, materials.star);
                scale = 1.5;
            } else if (type === 'RIBBON') {
                mesh = new THREE.Mesh(geometries.box, materials.ribbon);
                scale = 0.6;
                mesh.lookAt(0, pos.y, 0); 
            } else if (type === 'RED_BALL') {
                mesh = new THREE.Mesh(geometries.sphere, materials.ornamentRed);
                scale = 1.5;
            } else if (type === 'GOLD_BALL') {
                mesh = new THREE.Mesh(geometries.sphere, materials.ornamentGold);
                scale = 1.3;
            } else { 
                mesh = new THREE.Mesh(geometries.pine, materials.pine);
                scale = 2.0 + Math.random(); 
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            }

            mesh.position.copy(pos);
            mesh.scale.setScalar(scale);

            const scatterPos = new THREE.Vector3(
                (Math.random() - 0.5) * 280,
                (Math.random() - 0.5) * 200 + 70,
                (Math.random() - 0.5) * 150
            );

            scene.add(mesh);
            particles.push({
                mesh, treePos: pos.clone(), scatterPos, targetPos: pos.clone(),
                originalScale: scale, isPhoto: false,
                rotSpeed: { x: (Math.random()-0.5)*0.02, y: (Math.random()-0.5)*0.02 }
            });
        }

        function createPhotoParticle(texture, pos) {
            const aspect = texture.image.width / texture.image.height;
            const geo = new THREE.PlaneGeometry(CONFIG.photoSize * aspect, CONFIG.photoSize);
            
            const mat = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.DoubleSide,
                transparent: true,
                color: 0xbbbbbb 
            });
            
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            mesh.lookAt(0, pos.y, 0);
            mesh.rotateY(Math.PI); 

            const scatterPos = new THREE.Vector3(
                (Math.random() - 0.5) * 350,
                (Math.random() - 0.5) * 200 + 70,
                (Math.random() - 0.5) * 150
            );

            scene.add(mesh);
            particles.push({
                mesh, treePos: pos.clone(), scatterPos, targetPos: pos.clone(),
                originalScale: 1, isPhoto: true, rotSpeed: { x: 0, y: 0 }
            });
        }

        function updateState(newState, targetIdx) {
            if (currentState === newState && newState !== 'ZOOM') return;
            currentState = newState;
            if (newState === 'TREE') {
                gestureText.innerHTML = "STATUS: üéÑ <span style='color:#0f0'>Christmas Tree</span>";
                particles.forEach(p => { p.targetPos.copy(p.treePos); if(p.isPhoto) { p.mesh.lookAt(0, p.treePos.y, 0); p.mesh.rotateY(Math.PI); } });
                activePhotoIndex = -1;
                clearHighlight();
            } else if (newState === 'SCATTER') {
                gestureText.innerHTML = "STATUS: ‚ú® <span style='color:gold'>Magic Scatter</span>";
                particles.forEach(p => p.targetPos.copy(p.scatterPos));
                activePhotoIndex = -1;
                clearHighlight();
            } else if (newState === 'ZOOM') {
                gestureText.innerHTML = "STATUS: üñºÔ∏è <span style='color:#ff4d4d'>Memory Focus</span>";
                const photos = particles.filter(p => p.isPhoto);
                if (photos.length > 0) {
                    if (typeof targetIdx === 'number' && targetIdx >= 0 && particles[targetIdx] && particles[targetIdx].isPhoto) {
                        activePhotoIndex = targetIdx;
                    } else if (activePhotoIndex === -1 || !particles[activePhotoIndex].isPhoto) {
                        const randomPhoto = photos[Math.floor(Math.random() * photos.length)];
                        activePhotoIndex = particles.indexOf(randomPhoto);
                    }
                    const viewPos = new THREE.Vector3(0, 0, -35).applyQuaternion(camera.quaternion).add(camera.position);
                    particles[activePhotoIndex].targetPos.copy(viewPos);
                }
            }
        }

        function highlightPhoto(idx) {
            if (highlightedIndex === idx) return;
            clearHighlight();
            highlightedIndex = idx;
            const p = particles[idx];
            if (!p || !p.isPhoto) return;
            p.mesh.material.color.setHex(0xeeeecc);
            const params = p.mesh.geometry.parameters;
            const w = params.width * 1.08;
            const h = params.height * 1.08;
            const frameGeo = new THREE.PlaneGeometry(w, h);
            const frameMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            frame.position.copy(p.mesh.position);
            frame.quaternion.copy(p.mesh.quaternion);
            frame.renderOrder = (p.mesh.renderOrder || 0) - 1;
            p.mesh.userData.frame = frame;
            scene.add(frame);
        }

        function clearHighlight() {
            if (highlightedIndex === -1) return;
            const p = particles[highlightedIndex];
            if (p && p.isPhoto) {
                p.mesh.material.color.setHex(0xbbbbbb);
                if (p.mesh.userData.frame) { scene.remove(p.mesh.userData.frame); p.mesh.userData.frame = null; }
            }
            highlightedIndex = -1;
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = 0.05;

            particles.forEach((p, i) => {
                p.mesh.position.lerp(p.targetPos, dt);

                if (currentState === 'ZOOM' && i === activePhotoIndex) {
                    p.mesh.lookAt(camera.position);
                    if(p.isPhoto) p.mesh.material.color.setHex(0xffffff); 
                    p.mesh.scale.lerp(new THREE.Vector3(3,3,3), dt);
                } else {
                    if(p.isPhoto) p.mesh.material.color.setHex(0xbbbbbb);
                    
                    p.mesh.scale.lerp(new THREE.Vector3(p.originalScale, p.originalScale, p.originalScale), dt);
                    if (!p.isPhoto) {
                        p.mesh.rotation.x += p.rotSpeed.x;
                        p.mesh.rotation.y += p.rotSpeed.y;
                    }
                }
            });

            if (currentState === 'SCATTER') {
                scene.rotation.y += (targetRotationY - scene.rotation.y) * 0.05;
            } else {
                scene.rotation.y += 0.003; 
            }

            updateSnow();
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        const fileInput = document.getElementById('file-input');
        fileInput.addEventListener('change', async (e) => {
            const files = e.target.files;
            if (files.length === 0) return;
            loadingScreen.style.display = 'flex';
            photoTextures = [];
            const loadPromises = Array.from(files).map(file => {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.src = event.target.result;
                        img.onload = () => {
                            const tex = new THREE.Texture(img);
                            tex.colorSpace = THREE.SRGBColorSpace;
                            tex.needsUpdate = true;
                            photoTextures.push(tex);
                            resolve();
                        };
                    };
                    reader.readAsDataURL(file);
                });
            });
            await Promise.all(loadPromises);
            generateParticles();
            loadingScreen.style.display = 'none';
        });

        async function loadPhotosFromIndex() {
            try {
                loadingScreen.style.display = 'flex';
                const res = await fetch('photos-index.json', { cache: 'no-store' });
                if (!res.ok) throw new Error('index not found');
                const data = await res.json();
                const list = Array.isArray(data.images) ? data.images : [];
                photoTextures = [];
                const loadPromises = list.map((path) => new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.src = path;
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.colorSpace = THREE.SRGBColorSpace;
                        tex.needsUpdate = true;
                        photoTextures.push(tex);
                        resolve();
                    };
                    img.onerror = reject;
                }));
                await Promise.all(loadPromises);
                generateParticles();
            } catch (_) {
                // ignore
            } finally {
                loadingScreen.style.display = 'none';
            }
        }

        const videoElement = document.getElementById('video-preview');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.5 });
        hands.onResults(onHandsResults);
        
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });
        cameraUtils.start();

        function onHandsResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;
            const lm = results.multiHandLandmarks[0];
            const tips = [8, 12, 16, 20];
            const mcps = [5, 9, 13, 17];
            let extended = 0;
            if (Math.abs(lm[4].x - lm[17].x) > Math.abs(lm[2].x - lm[17].x)) extended++;
            for (let i = 0; i < 4; i++) { if (dist(lm[tips[i]], lm[0]) > dist(lm[mcps[i]], lm[0]) * 1.2) extended++; }
            const pinchDist = dist(lm[4], lm[8]);
            if (pinchDist < 0.12) {
                const pinchX = 1.0 - lm[8].x;
                const pinchY = lm[8].y;
                const ndc = { x: pinchX * 2 - 1, y: (1 - pinchY) * 2 - 1 };
                let targetIdx = -1;
                const photoMeshes = particles.filter(p => p.isPhoto).map(p => p.mesh);
                if (photoMeshes.length) {
                    raycaster.setFromCamera(ndc, camera);
                    const hits = raycaster.intersectObjects(photoMeshes, false);
                    if (hits.length) {
                        const mesh = hits[0].object;
                        targetIdx = particles.findIndex(p => p.mesh === mesh);
                    } else {
                        let best = Infinity; let idx = -1;
                        for (let i = 0; i < particles.length; i++) {
                            const p = particles[i]; if (!p.isPhoto) continue;
                            const v = p.mesh.position.clone().project(camera);
                            const dx = v.x - ndc.x; const dy = v.y - ndc.y; const d = dx*dx + dy*dy;
                            if (d < best) { best = d; idx = i; }
                        }
                        targetIdx = idx;
                    }
                }
                highlightPhoto(targetIdx);
                if (pinchDist < 0.05) updateState('ZOOM', targetIdx);
            }
            else if (extended >= 4) { updateState('SCATTER'); targetRotationY = (1.0 - lm[9].x - 0.5) * 5; }
            else if (extended <= 1) updateState('TREE');
        }

        function dist(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) + Math.pow(p1.z - p2.z, 2));
        }

        initThree();
        loadPhotosFromIndex();
    </script>
</body>
</html>
